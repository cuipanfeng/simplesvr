/**
 ***All Rights Reserved
 *
 *author zhengyinglin (979762787@qq.com)
 *date 2014-11-25
*/

/***
随机函数，参考下面实现
https://github.com/facebook/folly/blame/master/folly/Random.h
http://en.cppreference.com/w/cpp/numeric/random
http://stackoverflow.com/questions/15509270/does-stdmt19937-require-warmup
***/


#ifndef _UTIL_COMM_RANDOM_H_
#define _UTIL_COMM_RANDOM_H_

#include <stdint.h>
#include <random>
#include <array>
#include <algorithm>
#include <vector>
#include <initializer_list>

namespace util
{

namespace comm
{

//诡异的uniform_real_distribution 是开闭区间  uniform_int_distribution 却都是闭区间 
/*
    * http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution
    下面模板参数的取值
    Template parameters
        IntType	 -	 The result type generated by the generator. The effect is undefined if this is not one of short, int, long, long long, unsigned short, unsigned int, unsigned long, or unsigned long long.
*/    
class Random 
{
private:
    Random(std::seed_seq&& seq):
        m_rgen(seq)
    {
    }

public:
    static std::seed_seq createSeqArray()
    {
        std::array<int, std::mt19937::state_size> seed_data;
        std::random_device r;
        std::generate_n(seed_data.data(), seed_data.size(), std::ref(r));
        std::seed_seq  seq(seed_data.begin(), seed_data.end());
        return seq;
    }

    static Random& instance()
    {
        static Random instance_( createSeqArray() );
        return instance_;
    }

    /**
    * Returns a random IntType in [0, max). If max == 0, returns 0.
    */
    template< class IntType = int >
    inline IntType rand(IntType max)
    {
        if (max <= 0) 
        {
            return 0;
        }
        return std::uniform_int_distribution<IntType>(0, max - 1)(m_rgen);
    }

    /**
    * Returns a random IntType in [min, max). If min >= max, returns 0.
    */
    template< class IntType = int >
    inline IntType rand(IntType min, IntType max)
    {
        if (min >= max) 
        {
            return 0;
        }
        return std::uniform_int_distribution<IntType>(min, max - 1)(m_rgen);
    }
    
    /**
    * Returns a double in [min, max), if min == max, returns 0.
    */
    inline double randDouble(double min, double max)
    {
        if (std::fabs(max - min) < std::numeric_limits<double>::epsilon()) 
        {
            return 0;
        }
        return std::uniform_real_distribution<double>(min, max)(m_rgen);
    }

    // * Returns a random in array index in [0, len(weights) ).
    int weightRand(std::initializer_list<double>&& weights)
    {
        std::discrete_distribution<int> d(weights);
        return  d(m_rgen);
    }
    // * Returns a random in array index in [0, last - first).
    template< class InputIt >
    int weightRand( InputIt first, InputIt last )
    {
        std::discrete_distribution<int> d(first, last);
        return  d(m_rgen);
    }
  
private:
    std::mt19937  m_rgen;
};



//权重随机
class WeightRand
{
public:
    template< class InputIt >
    explicit WeightRand( InputIt first, InputIt last ):
        m_seq( Random::createSeqArray() ),
        m_rgen( m_seq ),
        m_d(first, last)
    {}

    explicit WeightRand(std::initializer_list<double> weights ):
        m_seq( Random::createSeqArray() ),
        m_rgen( m_seq ),
        m_d(weights)
    {}

public:

    //返回初始权重数组的下标
    int rand()
    {
        return m_d(m_rgen);
    }

private:
    std::seed_seq  m_seq;
    std::mt19937   m_rgen;
    std::discrete_distribution<int> m_d;
};



}//namespace comm

}//namespace util


#endif // _UTIL_COMM_RANDOM_H_
